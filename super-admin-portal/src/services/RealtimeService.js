/**
 * RealtimeService - Service x·ª≠ l√Ω d·ªØ li·ªáu realtime t·ª´ Firebase Realtime Database
 * K·∫ø th·ª´a t·ª´ BaseService ƒë·ªÉ s·ª≠ d·ª•ng c√°c utilities chung
 */

import { ref, get, onValue, off, set, update, remove } from 'firebase/database';
import { rtdb } from './firebase';
import BaseService from './BaseService';
import FirestoreService from './FirestoreService';

export class RealtimeService extends BaseService {

  // ===== GENERIC REALTIME OPERATIONS =====

  /**
   * L·∫•y d·ªØ li·ªáu t·ª´ m·ªôt path
   * @param {string} path - ƒê∆∞·ªùng d·∫´n ƒë·∫øn d·ªØ li·ªáu
   */
  static async getData(path) {
    try {
      const dataRef = ref(rtdb, path);
      const snapshot = await get(dataRef);
      
      if (snapshot.exists()) {
        return snapshot.val();
      }
      
      return null;
    } catch (error) {
      return this.handleError(error, `Getting realtime data from ${path}`, false);
    }
  }

  /**
   * Set d·ªØ li·ªáu t·∫°i m·ªôt path
   * @param {string} path - ƒê∆∞·ªùng d·∫´n ƒë·∫øn d·ªØ li·ªáu
   * @param {*} data - D·ªØ li·ªáu c·∫ßn set
   */
  static async setData(path, data) {
    try {
      const dataRef = ref(rtdb, path);
      await set(dataRef, data);
      return true;
    } catch (error) {
      return this.handleError(error, `Setting realtime data at ${path}`, false);
    }
  }

  /**
   * Update d·ªØ li·ªáu t·∫°i m·ªôt path
   * @param {string} path - ƒê∆∞·ªùng d·∫´n ƒë·∫øn d·ªØ li·ªáu
   * @param {Object} updates - Object ch·ª©a c√°c updates
   */
  static async updateData(path, updates) {
    try {
      const dataRef = ref(rtdb, path);
      await update(dataRef, updates);
      return true;
    } catch (error) {
      return this.handleError(error, `Updating realtime data at ${path}`, false);
    }
  }

  /**
   * X√≥a d·ªØ li·ªáu t·∫°i m·ªôt path
   * @param {string} path - ƒê∆∞·ªùng d·∫´n ƒë·∫øn d·ªØ li·ªáu
   */
  static async removeData(path) {
    try {
      const dataRef = ref(rtdb, path);
      await remove(dataRef);
      return true;
    } catch (error) {
      return this.handleError(error, `Removing realtime data at ${path}`, false);
    }
  }

  // ===== STATIONS REALTIME OPERATIONS =====

  /**
   * L·∫•y d·ªØ li·ªáu realtime c·ªßa t·∫•t c·∫£ stations
   */
  static async getRealtimeStations() {
    console.log('‚ö° Fetching realtime stations data...');
    const data = await this.getData('live/stations');
    console.log(`‚ö° Found ${data ? Object.keys(data).length : 0} realtime stations`);
    if (data && Object.keys(data).length > 0) {
      const firstKey = Object.keys(data)[0];
      console.log(`üìÑ Sample realtime station (${firstKey}):`, data[firstKey]);
    }
    return data;
  }

  /**
   * L·∫•y d·ªØ li·ªáu realtime c·ªßa m·ªôt station c·ª• th·ªÉ
   * @param {string} stationId - ID c·ªßa station
   */
  static async getRealtimeStation(stationId) {
    return this.getData(`live/stations/${stationId}`);
  }

  /**
   * L·∫•y tr·∫°ng th√°i connectors c·ªßa m·ªôt station
   * @param {string} stationId - ID c·ªßa station
   */
  static async getStationConnectors(stationId) {
    return this.getData(`live/stations/${stationId}/connectors`);
  }

  /**
   * L·∫•y tr·∫°ng th√°i m·ªôt connector c·ª• th·ªÉ
   * @param {string} stationId - ID c·ªßa station
   * @param {number} connectorId - ID c·ªßa connector
   */
  static async getConnectorStatus(stationId, connectorId) {
    return this.getData(`live/stations/${stationId}/connectors/${connectorId}`);
  }

  /**
   * L·∫•y th√¥ng tin session hi·ªán t·∫°i c·ªßa station
   * @param {string} stationId - ID c·ªßa station
   */
  static async getCurrentSession(stationId) {
    return this.getData(`live/stations/${stationId}/currentSession`);
  }

  /**
   * L·∫•y metrics realtime c·ªßa station
   * @param {string} stationId - ID c·ªßa station
   */
  static async getStationMetrics(stationId) {
    return this.getData(`live/stations/${stationId}/metrics`);
  }

  // ===== SUBSCRIPTION OPERATIONS =====

  /**
   * Subscribe to m·ªôt path ƒë·ªÉ l·∫Øng nghe thay ƒë·ªïi realtime
   * @param {string} path - ƒê∆∞·ªùng d·∫´n c·∫ßn subscribe
   * @param {Function} callback - Callback function khi c√≥ thay ƒë·ªïi
   * @param {Function} errorCallback - Callback function khi c√≥ l·ªói
   */
  static subscribeToPath(path, callback, errorCallback = null) {
    try {
      const dataRef = ref(rtdb, path);
      
      const unsubscribe = onValue(dataRef, (snapshot) => {
        if (snapshot.exists()) {
          callback(snapshot.val());
        } else {
          callback(null);
        }
      }, (error) => {
        console.error(`Realtime subscription error for ${path}:`, error);
        if (errorCallback) {
          errorCallback(error);
        } else {
          callback(null);
        }
      });

      // Return unsubscribe function
      return () => off(dataRef, 'value', unsubscribe);
    } catch (error) {
      this.handleError(error, `Subscribing to realtime path ${path}`, false);
      return () => {}; // Return empty function
    }
  }

  /**
   * Subscribe to m·ªôt station c·ª• th·ªÉ
   * @param {string} stationId - ID c·ªßa station
   * @param {Function} callback - Callback function
   * @param {Function} errorCallback - Error callback
   */
  static subscribeToStation(stationId, callback, errorCallback = null) {
    return this.subscribeToPath(`live/stations/${stationId}`, callback, errorCallback);
  }

  /**
   * Subscribe to t·∫•t c·∫£ stations
   * @param {Function} callback - Callback function
   * @param {Function} errorCallback - Error callback
   */
  static subscribeToAllStations(callback, errorCallback = null) {
    return this.subscribeToPath('live/stations', callback, errorCallback);
  }

  /**
   * Subscribe to connectors c·ªßa m·ªôt station
   * @param {string} stationId - ID c·ªßa station
   * @param {Function} callback - Callback function
   * @param {Function} errorCallback - Error callback
   */
  static subscribeToStationConnectors(stationId, callback, errorCallback = null) {
    return this.subscribeToPath(`live/stations/${stationId}/connectors`, callback, errorCallback);
  }

  /**
   * Subscribe to system events
   * @param {Function} callback - Callback function
   * @param {Function} errorCallback - Error callback
   */
  static subscribeToSystemEvents(callback, errorCallback = null) {
    return this.subscribeToPath('live/system/events', callback, errorCallback);
  }

  // ===== DATA SYNCHRONIZATION =====

  /**
   * ƒê·ªìng b·ªô d·ªØ li·ªáu t·ª´ Realtime Database sang Firestore
   * @param {string} ownerId - ID c·ªßa owner (optional, n·∫øu kh√¥ng c√≥ s·∫Ω sync t·∫•t c·∫£)
   * @param {boolean} forceSync - C√≥ force sync kh√¥ng (b·ªè qua cache)
   */
  static async syncRealtimeToFirestore(ownerId = null, forceSync = false) {
    try {
      console.log('üîÑ Starting sync from Realtime to Firestore...');
      
      // Check cache n·∫øu kh√¥ng force sync
      const cacheKey = `sync_${ownerId || 'all'}`;
      if (!forceSync) {
        const cached = this.getCached(cacheKey, 5 * 60 * 1000); // 5 minutes cache
        if (cached) {
          console.log('üìã Using cached sync result');
          return cached;
        }
      }

      // 1. L·∫•y t·∫•t c·∫£ d·ªØ li·ªáu realtime
      const realtimeStations = await this.getRealtimeStations();
      
      if (!realtimeStations || Object.keys(realtimeStations).length === 0) {
        console.log('‚ö†Ô∏è No realtime stations found');
        const result = { synced: 0, skipped: 0, errors: 0 };
        this.setCached(cacheKey, result);
        return result;
      }

      let syncedCount = 0;
      let skippedCount = 0;
      let errorCount = 0;

      // 2. Duy·ªát qua t·ª´ng station trong realtime data
      for (const [stationId, realtimeData] of Object.entries(realtimeStations)) {
        try {
          // N·∫øu ch·ªâ ƒë·ªãnh ownerId, ch·ªâ sync stations c·ªßa owner ƒë√≥
          if (ownerId && realtimeData.ownerId !== ownerId) {
            continue;
          }

          // Ki·ªÉm tra xem station ƒë√£ t·ªìn t·∫°i trong Firestore ch∆∞a
          const existingStation = await FirestoreService.checkStationExists(stationId);

          if (existingStation) {
            // Update th√¥ng tin realtime v√†o Firestore
            const updateData = {
              status: realtimeData.online ? 'online' : 'offline',
              lastHeartbeat: realtimeData.lastHeartbeat || null,
              connectors: realtimeData.connectors || {},
              // C·∫≠p nh·∫≠t th√¥ng tin t·ª´ realtime n·∫øu c√≥
              ...(realtimeData.vendor && { vendor: realtimeData.vendor }),
              ...(realtimeData.model && { model: realtimeData.model }),
              ...(realtimeData.firmwareVersion && { firmwareVersion: realtimeData.firmwareVersion })
            };

            await FirestoreService.updateStation(stationId, updateData);
            console.log(`üîÑ Updated station ${stationId} with realtime data`);
            syncedCount++;
          } else {
            // T·∫°o station m·ªõi trong Firestore t·ª´ d·ªØ li·ªáu realtime
            const firestoreData = {
              stationId: stationId,
              ownerId: realtimeData.ownerId || 'unknown',

              // Th√¥ng tin c∆° b·∫£n t·ª´ realtime
              vendor: realtimeData.vendor || 'Unknown',
              model: realtimeData.model || 'Unknown',
              firmwareVersion: realtimeData.firmwareVersion || 'N/A',

              // Th√¥ng tin cho app
              stationName: realtimeData.stationName || `Tr·∫°m s·∫°c ${stationId}`,
              address: realtimeData.address || '',
              latitude: realtimeData.latitude || null,
              longitude: realtimeData.longitude || null,

              // Tr·∫°ng th√°i
              status: realtimeData.online ? 'online' : 'offline',
              lastHeartbeat: realtimeData.lastHeartbeat || null,
              
              // Connectors
              connectors: realtimeData.connectors || {
                1: {
                  status: 'Available',
                  errorCode: 'NoError',
                  info: null,
                  vendorId: null,
                  vendorErrorCode: null,
                  lastUpdate: new Date().toISOString()
                },
                2: {
                  status: 'Available',
                  errorCode: 'NoError',
                  info: null,
                  vendorId: null,
                  vendorErrorCode: null,
                  lastUpdate: new Date().toISOString()
                }
              }
            };

            await FirestoreService.createStation(firestoreData);
            console.log(`‚úÖ Created station ${stationId} in Firestore from realtime data`);
            syncedCount++;
          }

        } catch (error) {
          console.error(`‚ùå Error syncing station ${stationId}:`, error);
          errorCount++;
        }
      }

      const result = { 
        synced: syncedCount, 
        skipped: skippedCount, 
        errors: errorCount,
        timestamp: new Date().toISOString()
      };

      console.log(`üéâ Sync completed: ${syncedCount} synced, ${skippedCount} skipped, ${errorCount} errors`);
      
      // Cache result
      this.setCached(cacheKey, result);
      
      return result;

    } catch (error) {
      return this.handleError(error, 'Syncing realtime to firestore');
    }
  }

  /**
   * ƒê·ªìng b·ªô d·ªØ li·ªáu t·ª´ Firestore sang Realtime Database
   * @param {string} stationId - ID c·ªßa station c·∫ßn sync
   * @param {Object} firestoreData - D·ªØ li·ªáu t·ª´ Firestore
   */
  static async syncFirestoreToRealtime(stationId, firestoreData) {
    try {
      const realtimeData = {
        stationId: firestoreData.stationId || stationId,
        ownerId: firestoreData.ownerId,
        stationName: firestoreData.stationName || `Tr·∫°m s·∫°c ${stationId}`,
        address: firestoreData.address || '',
        latitude: firestoreData.latitude || null,
        longitude: firestoreData.longitude || null,
        vendor: firestoreData.vendor || 'Unknown',
        model: firestoreData.model || 'Unknown',
        firmwareVersion: firestoreData.firmwareVersion || 'N/A',
        online: firestoreData.status === 'online',
        lastHeartbeat: firestoreData.lastHeartbeat,
        connectors: firestoreData.connectors || {},
        lastSync: new Date().toISOString()
      };

      await this.setData(`live/stations/${stationId}`, realtimeData);
      console.log(`‚úÖ Synced station ${stationId} from Firestore to Realtime`);
      
      return true;
    } catch (error) {
      return this.handleError(error, `Syncing station ${stationId} from Firestore to Realtime`, false);
    }
  }

  // ===== SYSTEM MONITORING =====

  /**
   * L·∫•y system health status
   */
  static async getSystemHealth() {
    try {
      const [systemStatus, stationsOnline, activeTransactions] = await Promise.all([
        this.getData('live/system/status'),
        this.getOnlineStationsCount(),
        this.getData('live/system/activeTransactions')
      ]);

      return {
        systemStatus: systemStatus || 'unknown',
        stationsOnline: stationsOnline || 0,
        activeTransactions: activeTransactions || 0,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return this.handleError(error, 'Getting system health', false);
    }
  }

  /**
   * ƒê·∫øm s·ªë l∆∞·ª£ng stations online
   */
  static async getOnlineStationsCount() {
    try {
      const stations = await this.getRealtimeStations();
      
      if (!stations) return 0;
      
      return Object.values(stations).filter(station => station.online === true).length;
    } catch (error) {
      this.handleError(error, 'Getting online stations count', false);
      return 0;
    }
  }

  /**
   * L·∫•y system alerts
   */
  static async getSystemAlerts() {
    return this.getData('live/system/alerts');
  }

  /**
   * T·∫°o system alert m·ªõi
   * @param {Object} alertData - D·ªØ li·ªáu alert
   */
  static async createSystemAlert(alertData) {
    const alertId = `alert_${Date.now()}`;
    const enhancedAlert = {
      ...alertData,
      id: alertId,
      timestamp: new Date().toISOString(),
      status: 'active'
    };

    return this.setData(`live/system/alerts/${alertId}`, enhancedAlert);
  }

  /**
   * Clear system alert
   * @param {string} alertId - ID c·ªßa alert
   */
  static async clearSystemAlert(alertId) {
    return this.removeData(`live/system/alerts/${alertId}`);
  }

  // ===== ANALYTICS & METRICS =====

  /**
   * L·∫•y realtime analytics data
   */
  static async getRealtimeAnalytics() {
    try {
      const analytics = await this.getData('live/analytics');
      
      if (!analytics) {
        return {
          totalStations: 0,
          onlineStations: 0,
          activeSessions: 0,
          totalEnergy: 0,
          totalRevenue: 0,
          timestamp: new Date().toISOString()
        };
      }

      return analytics;
    } catch (error) {
      return this.handleError(error, 'Getting realtime analytics', false);
    }
  }

  /**
   * Update realtime analytics
   * @param {Object} analyticsData - D·ªØ li·ªáu analytics
   */
  static async updateRealtimeAnalytics(analyticsData) {
    const enhancedData = {
      ...analyticsData,
      timestamp: new Date().toISOString()
    };

    return this.setData('live/analytics', enhancedData);
  }

  // ===== UTILITY METHODS =====

  /**
   * Ki·ªÉm tra k·∫øt n·ªëi realtime database
   */
  static async checkConnection() {
    try {
      const testRef = ref(rtdb, '.info/connected');
      const snapshot = await get(testRef);
      return snapshot.val() === true;
    } catch (error) {
      this.handleError(error, 'Checking realtime database connection', false);
      return false;
    }
  }

  /**
   * L·∫•y server timestamp
   */
  static async getServerTimestamp() {
    try {
      const timestampRef = ref(rtdb, '.info/serverTimeOffset');
      const snapshot = await get(timestampRef);
      const offset = snapshot.val() || 0;
      return new Date(Date.now() + offset);
    } catch (error) {
      this.handleError(error, 'Getting server timestamp', false);
      return new Date();
    }
  }

  /**
   * Cleanup old realtime data
   * @param {number} maxAge - Tu·ªïi t·ªëi ƒëa c·ªßa data (milliseconds)
   */
  static async cleanupOldData(maxAge = 7 * 24 * 60 * 60 * 1000) { // 7 days default
    try {
      const cutoffTime = Date.now() - maxAge;
      
      // Cleanup old alerts
      const alerts = await this.getData('live/system/alerts');
      if (alerts) {
        for (const [alertId, alert] of Object.entries(alerts)) {
          if (new Date(alert.timestamp).getTime() < cutoffTime) {
            await this.removeData(`live/system/alerts/${alertId}`);
          }
        }
      }

      // Cleanup old events
      const events = await this.getData('live/system/events');
      if (events) {
        for (const [eventId, event] of Object.entries(events)) {
          if (new Date(event.timestamp).getTime() < cutoffTime) {
            await this.removeData(`live/system/events/${eventId}`);
          }
        }
      }

      console.log('üßπ Cleaned up old realtime data');
      return true;
    } catch (error) {
      return this.handleError(error, 'Cleaning up old realtime data', false);
    }
  }

}

export default RealtimeService;